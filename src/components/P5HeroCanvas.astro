---
---

<div id="p5-hero-canvas" class="absolute inset-0 -z-10"></div>

<script>
  import p5 from 'p5';

  interface Particle {
    x: number;
    y: number;
    prevX: number;
    prevY: number;
    hue: number;
    alpha: number;
    speed: number;
    life: number;
    maxLife: number;
    isStar: boolean;
  }

  const sketch = (p: p5) => {
    const PARTICLE_COUNT = 700;
    const NOISE_SCALE = 0.0022;
    const BASE_SPEED = 1.6;
    const MOUSE_RADIUS = 150;

    let particles: Particle[] = [];
    let zOffset = 0;
    let hueShift = 0;
    let attractorX = 0;
    let attractorY = 0;
    let attractorAngle = 0;

    const createParticle = (fromEdge = false): Particle => {
      let x: number, y: number;
      if (fromEdge) {
        const side = Math.floor(p.random(4));
        if (side === 0)      { x = p.random(p.width);  y = -5; }
        else if (side === 1) { x = p.width + 5;         y = p.random(p.height); }
        else if (side === 2) { x = p.random(p.width);  y = p.height + 5; }
        else                 { x = -5;                  y = p.random(p.height); }
      } else {
        x = p.random(p.width);
        y = p.random(p.height);
      }
      const maxLife = p.random(150, 420);
      return {
        x, y, prevX: x, prevY: y,
        hue: p.random(260, 340),
        alpha: p.random(50, 90),
        speed: p.random(0.8, 2.0) * BASE_SPEED,
        life: 0,
        maxLife,
        isStar: p.random() < 0.04,
      };
    };

    p.setup = () => {
      const container = document.getElementById('p5-hero-canvas')!;
      const canvas = p.createCanvas(container.offsetWidth, container.offsetHeight);
      canvas.parent('p5-hero-canvas');
      p.colorMode(p.RGB);
      p.background(9, 5, 14);
      attractorX = p.width / 2;
      attractorY = p.height / 2;
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const pt = createParticle();
        pt.life = p.random(pt.maxLife); // ライフをずらして一斉起動を防ぐ
        particles.push(pt);
      }
    };

    p.draw = () => {
      // 半透明で塗りつぶして軌跡（トレイル）を作る
      p.noStroke();
      p.fill(9, 5, 14, 18);
      p.rect(0, 0, p.width, p.height);

      // アトラクターをリサージュ曲線（figure-8）で動かす
      attractorAngle += 0.004;
      attractorX = p.width  / 2 + Math.sin(attractorAngle)     * p.width  * 0.25;
      attractorY = p.height / 2 + Math.sin(attractorAngle * 2) * p.height * 0.18;

      // オーロラ効果のための色相シフト
      hueShift = (hueShift + 0.12) % 60;

      for (const pt of particles) {
        pt.prevX = pt.x;
        pt.prevY = pt.y;
        pt.life++;

        // フェードイン/アウト
        const lifeRatio = pt.life / pt.maxLife;
        const fade = lifeRatio < 0.1
          ? lifeRatio / 0.1
          : lifeRatio > 0.85
            ? (1 - lifeRatio) / 0.15
            : 1;

        // パーリンノイズで流れの角度を決定
        const angle = p.noise(pt.x * NOISE_SCALE, pt.y * NOISE_SCALE, zOffset) * p.TWO_PI * 4;
        let vx = Math.cos(angle) * pt.speed;
        let vy = Math.sin(angle) * pt.speed;

        // アトラクターへの引力（弱め）
        const adx = attractorX - pt.x;
        const ady = attractorY - pt.y;
        const aDist = Math.sqrt(adx * adx + ady * ady);
        if (aDist > 0 && aDist < p.width * 0.6) {
          const aForce = 0.15 * (1 - aDist / (p.width * 0.6));
          vx += (adx / aDist) * aForce;
          vy += (ady / aDist) * aForce;
        }

        // マウスの反発 + 渦巻き（接線方向の力を加えると vortex になる）
        const dx = pt.x - p.mouseX;
        const dy = pt.y - p.mouseY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < MOUSE_RADIUS && dist > 0) {
          const t = 1 - dist / MOUSE_RADIUS;
          vx += (dx / dist) * t * 5;   // 半径方向（反発）
          vy += (dy / dist) * t * 5;
          vx += (-dy / dist) * t * 2;  // 接線方向（渦）
          vy += (dx / dist) * t * 2;
        }

        pt.x += vx;
        pt.y += vy;

        // 色相シフトを適用した Purple → Violet → Pink グラデーション
        const hue = (pt.hue + hueShift) % 360;
        const hueRatio = Math.max(0, Math.min(1, (hue - 260) / 80));
        const r = Math.round(80  + hueRatio * 175);
        const g = Math.round(30  + hueRatio * 50);
        const b = Math.round(230 - hueRatio * 50);

        const speed = Math.sqrt(vx * vx + vy * vy);
        const finalAlpha = pt.alpha * fade;

        if (pt.isStar) {
          // 輝く点として描画
          p.noStroke();
          p.fill(Math.min(255, r * 1.6), Math.min(255, g * 2.5), Math.min(255, b * 1.2), finalAlpha * 0.7);
          p.circle(pt.x, pt.y, 2.5 + speed * 0.5);
        } else {
          p.stroke(r, g, b, finalAlpha);
          p.strokeWeight(Math.min(1.8, 0.7 + speed * 0.18));
          p.line(pt.prevX, pt.prevY, pt.x, pt.y);
        }

        // ライフ切れまたは画面外で再配置
        if (pt.life >= pt.maxLife || pt.x < -10 || pt.x > p.width + 10 || pt.y < -10 || pt.y > p.height + 10) {
          Object.assign(pt, createParticle(true));
        }
      }

      zOffset += 0.0015;
    };

    p.windowResized = () => {
      const container = document.getElementById('p5-hero-canvas')!;
      p.resizeCanvas(container.offsetWidth, container.offsetHeight);
      p.background(9, 5, 14);
      attractorX = p.width / 2;
      attractorY = p.height / 2;
    };
  };

  new p5(sketch);
</script>
